
from BuggySimulator import *
import numpy as np
import scipy
from scipy.ndimage import gaussian_filter1d
from util import *
import scipy.signal
    
class controller():
    
    def __init__(self,traj,vehicle):
        self.vehicle=vehicle
        self.traj=traj
        # Add additional member variables according to your need here.
        self.F = 100
        self.deltad = 0
        self.cum_error_x = 0
        self.cum_error_y = 0
        self.cum_error_delta = 0
        self.prev_error_x = 0
        self.prev_error_y = 0
        self.prev_error_delta = 0
        self.prev_delta = 0
        self.k_p_lat = 10
        self.k_i_lat = 0.1
        self.k_d_lat = 0.01
        self.k_p_long = 10
        self.k_i_long = 0.1
        self.k_d_long = 0.01

    def calc_pid_input(self):
        

    def control_update(self):

        traj=self.traj
        vehicle=self.vehicle 
        
        lr = vehicle.lr
        lf = vehicle.lf
        Ca = vehicle.Ca
        Iz = vehicle.Iz
        f = vehicle.f
        m = vehicle.m
        g = vehicle.g

        delT = 0.05   # The simulator runs at a constant fps.

        #reading current vehicle states
        X = vehicle.state.X
        Y = vehicle.state.Y
        xdot = vehicle.state.xd
        ydot = vehicle.state.yd
        phi = vehicle.state.phi
        phidot = vehicle.state.phid
        delta = vehicle.state.delta

        #Get desired X and Y values
        min_dist, min_ind = closest_node(X, Y, traj)
        X_desired = traj[min_ind+5, 0]
        Y_desired = traj[min_ind+5, 1]

        xdot_desired = (X - X_desired) / delT
        ydot_desired = (Y - Y_desired) / delT

        #phi_desired = np.arctan2(Y - Y_desired, X - X_desired)

        phi_desired = np.arctan2(ydot_desired, xdot_desired)
        #X_desired_next = traj[min_ind+5, 0]
        #Y_desired_next = traj[min_ind+5, 1]

        #X_next = X_desired_next - X_desired
        #Y_next = Y_desired_next - Y_desired

        #a = np.linalg.norm([X_desired_next, Y_desired_next])
        #b = np.linalg.norm([X_desired, Y_desired])

        #desired_angle = np.arctan(np.dot(a, b)/(a*b))

        # ---------------|Lateral Controller|-------------------------
        """
        Design your lateral controller here. 
        .

        .
        .
        .
        .
        .
        """ 
        x_error = X - X_desired
        y_error = Y - Y_desired
        #x_error = xdot - xdot_desired
        #y_error = ydot - ydot_desired
        delta_error = phi - phi_desired

        self.cum_error_x += x_error * delT
        self.cum_error_y += y_error * delT
        self.cum_error_delta += delta_error * delT

        diff_error_x = (x_error - self.prev_error_x) / delT
        diff_error_y = (y_error - self.prev_error_y) / delT
        diff_error_delta = (delta_error - self.prev_error_delta) / delT

        self.F = self.k_p_long * x_error + self.k_i_long * self.cum_error_x + self.k_d_long * diff_error_x
        self.deltad = self.k_p_lat * delta_error + self.k_i_lat * self.cum_error_delta + self.k_d_lat * diff_error_delta

        #self.deltad = (self.deltad - self.prev_delta) / delT
        self.prev_delta = self.deltad
        self.prev_error_x = x_error
        self.prev_error_y = y_error
        self.prev_error_delta = delta_error

        #--------|Longitudinal Controller|------------------------------
        """
        Desing your longitudinal controller here
        .
        .
        .
        .
        .
        .
        .

        """
        # Communicating the control commands with the BuggySimulator
        controlinp = vehicle.command(self.F, self.deltad)
        # F: Force
        # deltad: desired rate of steering command

        Vx = xdot
        return controlinp,Vx
