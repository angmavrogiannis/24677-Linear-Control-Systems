
from BuggySimulator import *
import numpy as np
import scipy
from scipy.ndimage import gaussian_filter1d
from util import *
import scipy.signal
    
class controller():
    
    def __init__(self,traj,vehicle):
        self.vehicle=vehicle
        self.traj=traj
        # Add additional member variables according to your need here.
        self.cum_error_x = 0
        self.cum_error_y = 0
        self.cum_error_delta = 0
        self.prev_error_x = 0
        self.prev_error_y = 0
        self.prev_error_delta = 0
        self.prev_delta = 0
        self.k_p_lat = 10
        self.k_i_lat = 5
        self.k_d_lat = 10
        self.k_p_long = 1000
        self.k_i_long = 10
        self.k_d_long = 10

    def control_update(self):

        traj=self.traj
        vehicle=self.vehicle 
        
        lr = vehicle.lr
        lf = vehicle.lf
        Ca = vehicle.Ca
        Iz = vehicle.Iz
        f = vehicle.f
        m = vehicle.m
        g = vehicle.g

        delT = 0.05   # The simulator runs at a constant fps.

        #reading current vehicle states
        X = vehicle.state.X
        Y = vehicle.state.Y
        xdot = vehicle.state.xd
        ydot = vehicle.state.yd
        phi = vehicle.state.phi
        phidot = vehicle.state.phid
        delta = vehicle.state.delta

        #Get desired X and Y values
        min_dist, min_ind = closest_node(X, Y, traj)
        if min_ind <= 8000:
            time_horizon = 20
        else:
            time_horizon = 0

        X_desired = traj[min_ind+time_horizon, 0]
        Y_desired = traj[min_ind+time_horizon, 1]

        xdot_desired = (X_desired - X) / delT
        # if min_ind<1900:
        #     xdot_desired = 35
        # elif min_ind>=1900 and min_ind<=2500:
        #     xdot_desired = 7
        # elif min_ind>2500 and min_ind<=5500:
        #     xdot_desired = 20.5
        # elif min_ind>5500 and min_ind<=6000:
        #     xdot_desired = 6.5
        # elif min_ind>7610 and min_ind<=7900:
        #     xdot_desired =9.3
        # else:
        #     xdot_desired = 30.5

        #xdot_desired = (X - X_desired) / delT
        #ydot_desired = (Y - Y_desired) / delT

        phi_desired = np.arctan2(Y_desired+time_horizon, X_desired+time_horizon)
        phi_desired = wrap2pi(phi_desired)

        # ---------------|Lateral Controller|-------------------------
        xdot_error = xdot_desired - xdot
        #y_error = Y - Y_desired
        #x_error = xdot - xdot_desired
        #y_error = ydot - ydot_desired
        delta_error = wrap2pi(phi_desired - phi)

        self.cum_error_x += xdot_error * delT
        #self.cum_error_y += y_error * delT
        self.cum_error_delta += delta_error * delT

        diff_error_x = (xdot_error - self.prev_error_x) / delT
        #diff_error_y = (y_error - self.prev_error_y) / delT
        diff_error_delta = (delta_error - self.prev_error_delta) / delT

        F = self.k_p_long * xdot_error + self.k_i_long * self.cum_error_x + self.k_d_long * diff_error_x
        deltad = self.k_p_lat * delta_error + self.k_i_lat * self.cum_error_delta + self.k_d_lat * diff_error_delta
        #deltad = (deltad - self.prev_delta) / (time_horizon)
        #self.deltad = (self.deltad - self.prev_delta) / delT
        self.prev_delta = delta
        self.prev_error_x = xdot_error
        #self.prev_error_y = y_error
        self.prev_error_delta = delta_error

        #--------|Longitudinal Controller|------------------------------

        # Communicating the control commands with the BuggySimulator
        controlinp = vehicle.command(F, deltad)
        # F: Force
        # deltad: desired rate of steering command

        Vx = xdot
        return controlinp,Vx
